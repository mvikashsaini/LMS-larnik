const mongoose = require('mongoose');

const CertificateSchema = new mongoose.Schema({
  certificateId: {
    type: String,
    required: [true, 'Please add certificate ID'],
    unique: true
  },
  student: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Please add student']
  },
  course: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course',
    required: [true, 'Please add course']
  },
  enrollment: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Enrollment',
    required: [true, 'Please add enrollment']
  },
  university: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'University',
    required: [true, 'Please add university']
  },
  teacher: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Please add teacher']
  },
  
  // Certificate details
  title: {
    type: String,
    required: [true, 'Please add certificate title']
  },
  description: String,
  issuedDate: {
    type: Date,
    default: Date.now
  },
  expiryDate: Date,
  
  // QR Code data
  qrCode: {
    data: String,
    imageUrl: String
  },
  
  // PDF file
  pdfFile: {
    url: String,
    fileName: String,
    fileSize: Number
  },
  
  // Certificate template
  template: {
    type: String,
    default: 'default-certificate-template.pdf'
  },
  
  // Certificate status
  status: {
    type: String,
    enum: ['generated', 'issued', 'expired', 'revoked'],
    default: 'generated'
  },
  
  // Validation (computed via virtual)
  revokedAt: Date,
  revokedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  revocationReason: String,
  
  // Certificate metadata
  metadata: {
    courseDuration: Number, // in minutes
    completionDate: Date,
    score: Number,
    maxScore: Number,
    grade: String,
    achievements: [String]
  },
  
  // Signatories
  signatories: [{
    name: String,
    designation: String,
    signature: String,
    signedAt: Date
  }],
  
  // Verification
  verificationUrl: String,
  verificationCode: String
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
CertificateSchema.index({ certificateId: 1 });
CertificateSchema.index({ student: 1 });
CertificateSchema.index({ course: 1 });
CertificateSchema.index({ status: 1 });
CertificateSchema.index({ issuedDate: -1 });
CertificateSchema.index({ qrCode: 1 });
CertificateSchema.index({ verificationCode: 1 });

// Virtual for certificate validity
CertificateSchema.virtual('isValid').get(function() {
  if (this.status === 'revoked') return false;
  if (this.expiryDate && new Date() > this.expiryDate) return false;
  return true;
});

// Virtual for certificate age
CertificateSchema.virtual('age').get(function() {
  if (!this.issuedDate) return 0;
  return Math.floor((new Date() - this.issuedDate) / (1000 * 60 * 60 * 24)); // days
});

// Generate unique certificate ID
CertificateSchema.methods.generateCertificateId = function() {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substr(2, 5);
  return `CERT-${timestamp}-${random}`.toUpperCase();
};

// Generate QR code data
CertificateSchema.methods.generateQRData = function() {
  const data = {
    certificateId: this.certificateId,
    studentId: this.student.toString(),
    courseId: this.course.toString(),
    issuedDate: this.issuedDate.toISOString(),
    verificationUrl: `${process.env.FRONTEND_URL}/verify/${this.certificateId}`
  };
  
  return JSON.stringify(data);
};

// Generate verification code
CertificateSchema.methods.generateVerificationCode = function() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < 8; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
};

// Mark certificate as issued
CertificateSchema.methods.issue = function() {
  this.status = 'issued';
  this.issuedDate = new Date();
  
  // Generate certificate ID if not exists
  if (!this.certificateId) {
    this.certificateId = this.generateCertificateId();
  }
  
  // Generate QR code data
  this.qrCode = {
    data: this.generateQRData(),
    imageUrl: null // Will be generated by service
  };
  
  // Generate verification code
  this.verificationCode = this.generateVerificationCode();
  this.verificationUrl = `${process.env.FRONTEND_URL}/verify/${this.certificateId}`;
  
  return this.save();
};

// Revoke certificate
CertificateSchema.methods.revoke = function(reason, revokedBy) {
  this.status = 'revoked';
  this.revokedAt = new Date();
  this.revokedBy = revokedBy;
  this.revocationReason = reason;
  
  return this.save();
};

// Validate certificate
CertificateSchema.methods.validate = function() {
  if (this.status === 'revoked') {
    return { valid: false, reason: 'Certificate has been revoked' };
  }
  
  if (this.expiryDate && new Date() > this.expiryDate) {
    return { valid: false, reason: 'Certificate has expired' };
  }
  
  return { valid: true };
};

// Get certificate analytics
CertificateSchema.statics.getAnalytics = async function() {
  const analytics = await this.aggregate([
    {
      $group: {
        _id: null,
        totalCertificates: { $sum: 1 },
        issuedCertificates: {
          $sum: {
            $cond: [{ $eq: ['$status', 'issued'] }, 1, 0]
          }
        },
        revokedCertificates: {
          $sum: {
            $cond: [{ $eq: ['$status', 'revoked'] }, 1, 0]
          }
        },
        expiredCertificates: {
          $sum: {
            $cond: [
              { 
                $and: [
                  { $ne: ['$expiryDate', null] },
                  { $lt: ['$expiryDate', new Date()] }
                ]
              }, 
              1, 
              0
            ]
          }
        }
      }
    }
  ]);
  
  return analytics[0] || {
    totalCertificates: 0,
    issuedCertificates: 0,
    revokedCertificates: 0,
    expiredCertificates: 0
  };
};

// Get certificates by date range
CertificateSchema.statics.getCertificatesByDateRange = async function(startDate, endDate) {
  return this.find({
    issuedDate: {
      $gte: startDate,
      $lte: endDate
    }
  }).populate('student', 'firstName lastName email')
    .populate('course', 'title')
    .populate('university', 'name')
    .populate('teacher', 'firstName lastName')
    .sort({ issuedDate: -1 });
};

// Cascade delete related data when certificate is deleted
CertificateSchema.pre('remove', async function(next) {
  // Update enrollment to remove certificate reference
  await this.model('Enrollment').updateOne(
    { _id: this.enrollment },
    { $unset: { certificate: 1 } }
  );
  
  // Update student's certificates array
  await this.model('User').updateOne(
    { _id: this.student },
    { $pull: { 'studentProfile.certificates': this._id } }
  );
  
  next();
});

module.exports = mongoose.model('Certificate', CertificateSchema);
